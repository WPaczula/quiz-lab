{"version":3,"file":"components.js","sources":["../lib/components/FlyingSquare/helpers.ts","../lib/components/FlyingSquare/FlyingSquare.tsx","../lib/components/Latency/Latency.tsx","../node_modules/classnames/index.js","../lib/components/Tile/Tile.tsx","../lib/components/Timer/Timer.tsx","context-CoVyjGLq.js","main.js","../lib/utility/url.ts","../lib/components/Navigator/GenericNavigator.tsx","../lib/components/Navigator/GameNavigator.tsx"],"sourcesContent":["const getRandomBorderPosition = (squareSize: number) => {\n  const position: { top?: string; left?: string } = {};\n  const randomValue = Math.random();\n\n  if (randomValue < 0.25) {\n    // Top border\n    position.top = `-${squareSize}px`;\n    position.left = Math.random() * window.innerWidth + \"px\";\n  } else if (randomValue < 0.5) {\n    // Right border\n    position.top = Math.random() * window.innerHeight + \"px\";\n    position.left = window.innerWidth + \"px\";\n  } else if (randomValue < 0.75) {\n    // Bottom border\n    position.top = window.innerHeight + \"px\";\n    position.left = Math.random() * window.innerWidth + \"px\";\n  } else {\n    // Left border\n    position.top = Math.random() * window.innerHeight + \"px\";\n    position.left = `-${squareSize}px`;\n  }\n\n  return position;\n};\n\nexport const flySquare = (square: HTMLDivElement) => {\n  const squareSize = square.offsetWidth;\n  const startPosition = getRandomBorderPosition(squareSize);\n  const endPosition = getRandomBorderPosition(squareSize);\n\n  square.style.top = startPosition.top!;\n  square.style.left = startPosition.left!;\n\n  const duration = 30_000; // 5 seconds\n  const startTime = performance.now();\n\n  const animate = (time: number) => {\n    const elapsed = time - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n\n    square.style.top = `calc(${startPosition.top} + (${parseFloat(endPosition.top!) - parseFloat(startPosition.top!)}px) * ${progress})`;\n    square.style.left = `calc(${startPosition.left} + (${parseFloat(endPosition.left!) - parseFloat(startPosition.left!)}px) * ${progress})`;\n\n    if (progress < 1) {\n      requestAnimationFrame(animate);\n    } else {\n      flySquare(square);\n    }\n  };\n\n  requestAnimationFrame(animate);\n};\n","import React, { memo, useEffect, useRef } from \"react\";\nimport { flySquare } from \"./helpers\";\nimport styles from \"./FlyingSquare.module.scss\";\n\ninterface FlyingSquareProps {\n  count?: number;\n}\n\nconst FlyingSquare: React.FC<FlyingSquareProps> = ({ count = 1 }) => {\n  const squareRefs = useRef<HTMLDivElement[]>([]);\n\n  useEffect(() => {\n    squareRefs.current.forEach((square) => {\n      if (square) {\n        flySquare(square);\n      }\n    });\n  }, [count]);\n\n  return (\n    <div>\n      {Array.from({ length: count }).map((_, index) => (\n        <div\n          key={index}\n          ref={(el) => {\n            if (el) squareRefs.current[index] = el;\n          }}\n          className={styles.square}\n        ></div>\n      ))}\n    </div>\n  );\n};\n\nexport default memo(FlyingSquare);\n","import { useLocalSyncConsumer } from \"@/hooks/useLocalSyncConsumer\";\nimport { useLocalSyncService } from \"@/hooks/useLocalSyncService\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport styles from \"./Latency.module.scss\";\n\nconst Latency = () => {\n  const [latency, setLatency] = useState<number>(0);\n  const timestamp = useRef<number>(Date.now());\n\n  const { connected, sendSync } = useLocalSyncService();\n\n  useEffect(() => {\n    if (!connected) return;\n\n    const interval = setInterval(() => {\n      timestamp.current = Date.now();\n      // sendSync(\"Ping\");\n    }, 5_000);\n\n    return () => clearInterval(interval);\n  }, [connected, sendSync]);\n\n  useLocalSyncConsumer(\n    \"Pong\",\n    \"Latency\",\n    useCallback(async () => {\n      const newLatency = Date.now() - timestamp.current;\n      setLatency(newLatency);\n    }, []),\n  );\n\n  return (\n    <span className={styles.latency}>{connected ? `${latency}ms` : \"---\"}</span>\n  );\n};\n\nexport default Latency;\n","/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import classNames from \"classnames\";\nimport styles from \"./Tile.module.scss\";\n\ntype Props = {\n  text: string;\n  blue?: boolean;\n  className?: string;\n  selected?: boolean;\n  success?: boolean;\n  failure?: boolean;\n  onClick?: () => void;\n};\n\nconst Tile = ({\n  text,\n  blue = false,\n  selected = false,\n  success = false,\n  failure = false,\n  onClick,\n}: Props) => {\n  return (\n    <div\n      onClick={onClick}\n      className={classNames(styles.tile, {\n        [styles.blue]: blue,\n        [styles.selected]: selected,\n        [styles.success]: success,\n        [styles.failure]: failure,\n      })}\n    >\n      <p>{text}</p>\n    </div>\n  );\n};\n\nexport default Tile;\n","import React, { useState, useEffect } from \"react\";\nimport styles from \"./Timer.module.scss\";\nimport classNames from \"classnames\";\n\ntype Props = {\n  startSeconds: number; // Total countdown time in seconds\n  onTimeUp?: () => void; // Callback function when time is up\n};\n\nconst Timer: React.FC<Props> = ({ startSeconds, onTimeUp }) => {\n  const [timeLeft, setTimeLeft] = useState(startSeconds);\n  const [percentage, setPercentage] = useState(0);\n\n  useEffect(() => {\n    if (timeLeft > 0) {\n      const interval = setInterval(() => {\n        setTimeLeft((prevTime) => prevTime - 1);\n      }, 1_000);\n      return () => clearInterval(interval); // Clear the interval on unmount\n    } else {\n      setTimeout(() => {\n        onTimeUp?.();\n      }, 100);\n    }\n  }, [timeLeft, onTimeUp]);\n\n  useEffect(() => {\n    // Calculate the percentage of time passed\n    const timeElapsed = startSeconds - (timeLeft - 1);\n    setPercentage((timeElapsed / startSeconds) * 100);\n  }, [timeLeft, startSeconds]);\n\n  // Determine color based on the percentage\n  const getProgressColor = () => {\n    if (percentage < 33) return \"green\";\n    if (percentage < 66) return \"yellow\";\n    return \"red\";\n  };\n\n  return (\n    <div className={styles.timer}>\n      <div className={styles[\"progress-bar\"]}>\n        <div\n          style={{ width: `${percentage}%` }}\n          className={classNames(\n            styles[\"progress-fill\"],\n            styles[getProgressColor()],\n          )}\n        />\n      </div>\n      <div className={styles.display}>\n        {`${Math.floor(timeLeft / 60)\n          .toString()\n          .padStart(2, \"0\")}:${(timeLeft % 60).toString().padStart(2, \"0\")}`}\n      </div>\n    </div>\n  );\n};\nexport default Timer;\n","import { createContext as o } from \"react\";\nconst e = o(void 0);\nexport {\n  e as L\n};\n//# sourceMappingURL=context-CoVyjGLq.js.map\n","var F = Object.defineProperty;\nvar q = (s, e, t) => e in s ? F(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;\nvar w = (s, e, t) => q(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nimport { jsx as z } from \"react/jsx-runtime\";\nimport { useState as G, useRef as J, useEffect as K } from \"react\";\nimport { L as X } from \"./context-CoVyjGLq.js\";\nvar V = /* @__PURE__ */ ((s) => (s[s.GameCreated = 1] = \"GameCreated\", s[s.GameJoined = 2] = \"GameJoined\", s[s.GameStarting = 3] = \"GameStarting\", s[s.GameStarted = 4] = \"GameStarted\", s[s.RulesExplaining = 5] = \"RulesExplaining\", s[s.RulesExplained = 6] = \"RulesExplained\", s[s.MiniGameStarting = 7] = \"MiniGameStarting\", s[s.MiniGameStarted = 8] = \"MiniGameStarted\", s[s.MiniGameEnding = 9] = \"MiniGameEnding\", s[s.MiniGameEnded = 10] = \"MiniGameEnded\", s[s.GameEnding = 11] = \"GameEnding\", s[s.GameEnded = 12] = \"GameEnded\", s))(V || {});\nconst Le = {\n  1: \"GameCreated\",\n  2: \"GameJoined\",\n  3: \"GameStarting\",\n  4: \"GameStarted\",\n  5: \"RulesExplaining\",\n  6: \"RulesExplained\",\n  7: \"MiniGameStarting\",\n  8: \"MiniGameStarted\",\n  9: \"MiniGameEnding\",\n  10: \"MiniGameEnded\",\n  11: \"GameEnding\",\n  12: \"GameEnded\"\n};\nclass y extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\n   *\n   * @param {string} errorMessage A descriptive error message.\n   * @param {number} statusCode The HTTP status code represented by this error.\n   */\n  constructor(e, t) {\n    const n = new.target.prototype;\n    super(`${e}: Status code '${t}'`), this.statusCode = t, this.__proto__ = n;\n  }\n}\nclass x extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\n   *\n   * @param {string} errorMessage A descriptive error message.\n   */\n  constructor(e = \"A timeout occurred.\") {\n    const t = new.target.prototype;\n    super(e), this.__proto__ = t;\n  }\n}\nclass C extends Error {\n  /** Constructs a new instance of {@link AbortError}.\n   *\n   * @param {string} errorMessage A descriptive error message.\n   */\n  constructor(e = \"An abort occurred.\") {\n    const t = new.target.prototype;\n    super(e), this.__proto__ = t;\n  }\n}\nclass Q extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\n   *\n   * @param {string} message A descriptive error message.\n   * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\n   */\n  constructor(e, t) {\n    const n = new.target.prototype;\n    super(e), this.transport = t, this.errorType = \"UnsupportedTransportError\", this.__proto__ = n;\n  }\n}\nclass Y extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\n   *\n   * @param {string} message A descriptive error message.\n   * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\n   */\n  constructor(e, t) {\n    const n = new.target.prototype;\n    super(e), this.transport = t, this.errorType = \"DisabledTransportError\", this.__proto__ = n;\n  }\n}\nclass Z extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\n   *\n   * @param {string} message A descriptive error message.\n   * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\n   */\n  constructor(e, t) {\n    const n = new.target.prototype;\n    super(e), this.transport = t, this.errorType = \"FailedToStartTransportError\", this.__proto__ = n;\n  }\n}\nclass W extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\n   *\n   * @param {string} message A descriptive error message.\n   */\n  constructor(e) {\n    const t = new.target.prototype;\n    super(e), this.errorType = \"FailedToNegotiateWithServerError\", this.__proto__ = t;\n  }\n}\nclass ee extends Error {\n  /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\n   *\n   * @param {string} message A descriptive error message.\n   * @param {Error[]} innerErrors The collection of errors this error is aggregating.\n   */\n  constructor(e, t) {\n    const n = new.target.prototype;\n    super(e), this.innerErrors = t, this.__proto__ = n;\n  }\n}\nclass B {\n  constructor(e, t, n) {\n    this.statusCode = e, this.statusText = t, this.content = n;\n  }\n}\nclass D {\n  get(e, t) {\n    return this.send({\n      ...t,\n      method: \"GET\",\n      url: e\n    });\n  }\n  post(e, t) {\n    return this.send({\n      ...t,\n      method: \"POST\",\n      url: e\n    });\n  }\n  delete(e, t) {\n    return this.send({\n      ...t,\n      method: \"DELETE\",\n      url: e\n    });\n  }\n  /** Gets all cookies that apply to the specified URL.\n   *\n   * @param url The URL that the cookies are valid for.\n   * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\n   */\n  // @ts-ignore\n  getCookieString(e) {\n    return \"\";\n  }\n}\nvar i;\n(function(s) {\n  s[s.Trace = 0] = \"Trace\", s[s.Debug = 1] = \"Debug\", s[s.Information = 2] = \"Information\", s[s.Warning = 3] = \"Warning\", s[s.Error = 4] = \"Error\", s[s.Critical = 5] = \"Critical\", s[s.None = 6] = \"None\";\n})(i || (i = {}));\nclass I {\n  constructor() {\n  }\n  /** @inheritDoc */\n  // eslint-disable-next-line\n  log(e, t) {\n  }\n}\nI.instance = new I();\nconst te = \"8.0.7\";\nclass f {\n  static isRequired(e, t) {\n    if (e == null)\n      throw new Error(`The '${t}' argument is required.`);\n  }\n  static isNotEmpty(e, t) {\n    if (!e || e.match(/^\\s*$/))\n      throw new Error(`The '${t}' argument should not be empty.`);\n  }\n  static isIn(e, t, n) {\n    if (!(e in t))\n      throw new Error(`Unknown ${n} value: ${e}.`);\n  }\n}\nclass _ {\n  // react-native has a window but no document so we should check both\n  static get isBrowser() {\n    return !_.isNode && typeof window == \"object\" && typeof window.document == \"object\";\n  }\n  // WebWorkers don't have a window object so the isBrowser check would fail\n  static get isWebWorker() {\n    return !_.isNode && typeof self == \"object\" && \"importScripts\" in self;\n  }\n  // react-native has a window but no document\n  static get isReactNative() {\n    return !_.isNode && typeof window == \"object\" && typeof window.document > \"u\";\n  }\n  // Node apps shouldn't have a window object, but WebWorkers don't either\n  // so we need to check for both WebWorker and window\n  static get isNode() {\n    return typeof process < \"u\" && process.release && process.release.name === \"node\";\n  }\n}\nfunction T(s, e) {\n  let t = \"\";\n  return k(s) ? (t = `Binary data of length ${s.byteLength}`, e && (t += `. Content: '${ne(s)}'`)) : typeof s == \"string\" && (t = `String data of length ${s.length}`, e && (t += `. Content: '${s}'`)), t;\n}\nfunction ne(s) {\n  const e = new Uint8Array(s);\n  let t = \"\";\n  return e.forEach((n) => {\n    const o = n < 16 ? \"0\" : \"\";\n    t += `0x${o}${n.toString(16)} `;\n  }), t.substr(0, t.length - 1);\n}\nfunction k(s) {\n  return s && typeof ArrayBuffer < \"u\" && (s instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n  s.constructor && s.constructor.name === \"ArrayBuffer\");\n}\nasync function j(s, e, t, n, o, r) {\n  const c = {}, [a, l] = E();\n  c[a] = l, s.log(i.Trace, `(${e} transport) sending data. ${T(o, r.logMessageContent)}.`);\n  const u = k(o) ? \"arraybuffer\" : \"text\", d = await t.post(n, {\n    content: o,\n    headers: { ...c, ...r.headers },\n    responseType: u,\n    timeout: r.timeout,\n    withCredentials: r.withCredentials\n  });\n  s.log(i.Trace, `(${e} transport) request complete. Response status: ${d.statusCode}.`);\n}\nfunction oe(s) {\n  return s === void 0 ? new R(i.Information) : s === null ? I.instance : s.log !== void 0 ? s : new R(s);\n}\nclass se {\n  constructor(e, t) {\n    this._subject = e, this._observer = t;\n  }\n  dispose() {\n    const e = this._subject.observers.indexOf(this._observer);\n    e > -1 && this._subject.observers.splice(e, 1), this._subject.observers.length === 0 && this._subject.cancelCallback && this._subject.cancelCallback().catch((t) => {\n    });\n  }\n}\nclass R {\n  constructor(e) {\n    this._minLevel = e, this.out = console;\n  }\n  log(e, t) {\n    if (e >= this._minLevel) {\n      const n = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${i[e]}: ${t}`;\n      switch (e) {\n        case i.Critical:\n        case i.Error:\n          this.out.error(n);\n          break;\n        case i.Warning:\n          this.out.warn(n);\n          break;\n        case i.Information:\n          this.out.info(n);\n          break;\n        default:\n          this.out.log(n);\n          break;\n      }\n    }\n  }\n}\nfunction E() {\n  let s = \"X-SignalR-User-Agent\";\n  return _.isNode && (s = \"User-Agent\"), [s, re(te, ie(), ae(), ce())];\n}\nfunction re(s, e, t, n) {\n  let o = \"Microsoft SignalR/\";\n  const r = s.split(\".\");\n  return o += `${r[0]}.${r[1]}`, o += ` (${s}; `, e && e !== \"\" ? o += `${e}; ` : o += \"Unknown OS; \", o += `${t}`, n ? o += `; ${n}` : o += \"; Unknown Runtime Version\", o += \")\", o;\n}\nfunction ie() {\n  if (_.isNode)\n    switch (process.platform) {\n      case \"win32\":\n        return \"Windows NT\";\n      case \"darwin\":\n        return \"macOS\";\n      case \"linux\":\n        return \"Linux\";\n      default:\n        return process.platform;\n    }\n  else\n    return \"\";\n}\nfunction ce() {\n  if (_.isNode)\n    return process.versions.node;\n}\nfunction ae() {\n  return _.isNode ? \"NodeJS\" : \"Browser\";\n}\nfunction $(s) {\n  return s.stack ? s.stack : s.message ? s.message : `${s}`;\n}\nfunction le() {\n  if (typeof globalThis < \"u\")\n    return globalThis;\n  if (typeof self < \"u\")\n    return self;\n  if (typeof window < \"u\")\n    return window;\n  if (typeof global < \"u\")\n    return global;\n  throw new Error(\"could not find global\");\n}\nclass he extends D {\n  constructor(e) {\n    if (super(), this._logger = e, typeof fetch > \"u\" || _.isNode) {\n      const t = typeof __webpack_require__ == \"function\" ? __non_webpack_require__ : require;\n      this._jar = new (t(\"tough-cookie\")).CookieJar(), typeof fetch > \"u\" ? this._fetchType = t(\"node-fetch\") : this._fetchType = fetch, this._fetchType = t(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else\n      this._fetchType = fetch.bind(le());\n    if (typeof AbortController > \"u\") {\n      const t = typeof __webpack_require__ == \"function\" ? __non_webpack_require__ : require;\n      this._abortControllerType = t(\"abort-controller\");\n    } else\n      this._abortControllerType = AbortController;\n  }\n  /** @inheritDoc */\n  async send(e) {\n    if (e.abortSignal && e.abortSignal.aborted)\n      throw new C();\n    if (!e.method)\n      throw new Error(\"No method defined.\");\n    if (!e.url)\n      throw new Error(\"No url defined.\");\n    const t = new this._abortControllerType();\n    let n;\n    e.abortSignal && (e.abortSignal.onabort = () => {\n      t.abort(), n = new C();\n    });\n    let o = null;\n    if (e.timeout) {\n      const l = e.timeout;\n      o = setTimeout(() => {\n        t.abort(), this._logger.log(i.Warning, \"Timeout from HTTP request.\"), n = new x();\n      }, l);\n    }\n    e.content === \"\" && (e.content = void 0), e.content && (e.headers = e.headers || {}, k(e.content) ? e.headers[\"Content-Type\"] = \"application/octet-stream\" : e.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\");\n    let r;\n    try {\n      r = await this._fetchType(e.url, {\n        body: e.content,\n        cache: \"no-cache\",\n        credentials: e.withCredentials === !0 ? \"include\" : \"same-origin\",\n        headers: {\n          \"X-Requested-With\": \"XMLHttpRequest\",\n          ...e.headers\n        },\n        method: e.method,\n        mode: \"cors\",\n        redirect: \"follow\",\n        signal: t.signal\n      });\n    } catch (l) {\n      throw n || (this._logger.log(i.Warning, `Error from HTTP request. ${l}.`), l);\n    } finally {\n      o && clearTimeout(o), e.abortSignal && (e.abortSignal.onabort = null);\n    }\n    if (!r.ok) {\n      const l = await N(r, \"text\");\n      throw new y(l || r.statusText, r.status);\n    }\n    const a = await N(r, e.responseType);\n    return new B(r.status, r.statusText, a);\n  }\n  getCookieString(e) {\n    let t = \"\";\n    return _.isNode && this._jar && this._jar.getCookies(e, (n, o) => t = o.join(\"; \")), t;\n  }\n}\nfunction N(s, e) {\n  let t;\n  switch (e) {\n    case \"arraybuffer\":\n      t = s.arrayBuffer();\n      break;\n    case \"text\":\n      t = s.text();\n      break;\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(`${e} is not supported.`);\n    default:\n      t = s.text();\n      break;\n  }\n  return t;\n}\nclass ue extends D {\n  constructor(e) {\n    super(), this._logger = e;\n  }\n  /** @inheritDoc */\n  send(e) {\n    return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new C()) : e.method ? e.url ? new Promise((t, n) => {\n      const o = new XMLHttpRequest();\n      o.open(e.method, e.url, !0), o.withCredentials = e.withCredentials === void 0 ? !0 : e.withCredentials, o.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), e.content === \"\" && (e.content = void 0), e.content && (k(e.content) ? o.setRequestHeader(\"Content-Type\", \"application/octet-stream\") : o.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\"));\n      const r = e.headers;\n      r && Object.keys(r).forEach((c) => {\n        o.setRequestHeader(c, r[c]);\n      }), e.responseType && (o.responseType = e.responseType), e.abortSignal && (e.abortSignal.onabort = () => {\n        o.abort(), n(new C());\n      }), e.timeout && (o.timeout = e.timeout), o.onload = () => {\n        e.abortSignal && (e.abortSignal.onabort = null), o.status >= 200 && o.status < 300 ? t(new B(o.status, o.statusText, o.response || o.responseText)) : n(new y(o.response || o.responseText || o.statusText, o.status));\n      }, o.onerror = () => {\n        this._logger.log(i.Warning, `Error from HTTP request. ${o.status}: ${o.statusText}.`), n(new y(o.statusText, o.status));\n      }, o.ontimeout = () => {\n        this._logger.log(i.Warning, \"Timeout from HTTP request.\"), n(new x());\n      }, o.send(e.content);\n    }) : Promise.reject(new Error(\"No url defined.\")) : Promise.reject(new Error(\"No method defined.\"));\n  }\n}\nclass de extends D {\n  /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\n  constructor(e) {\n    if (super(), typeof fetch < \"u\" || _.isNode)\n      this._httpClient = new he(e);\n    else if (typeof XMLHttpRequest < \"u\")\n      this._httpClient = new ue(e);\n    else\n      throw new Error(\"No usable HttpClient found.\");\n  }\n  /** @inheritDoc */\n  send(e) {\n    return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new C()) : e.method ? e.url ? this._httpClient.send(e) : Promise.reject(new Error(\"No url defined.\")) : Promise.reject(new Error(\"No method defined.\"));\n  }\n  getCookieString(e) {\n    return this._httpClient.getCookieString(e);\n  }\n}\nclass b {\n  static write(e) {\n    return `${e}${b.RecordSeparator}`;\n  }\n  static parse(e) {\n    if (e[e.length - 1] !== b.RecordSeparator)\n      throw new Error(\"Message is incomplete.\");\n    const t = e.split(b.RecordSeparator);\n    return t.pop(), t;\n  }\n}\nb.RecordSeparatorCode = 30;\nb.RecordSeparator = String.fromCharCode(b.RecordSeparatorCode);\nclass ge {\n  // Handshake request is always JSON\n  writeHandshakeRequest(e) {\n    return b.write(JSON.stringify(e));\n  }\n  parseHandshakeResponse(e) {\n    let t, n;\n    if (k(e)) {\n      const a = new Uint8Array(e), l = a.indexOf(b.RecordSeparatorCode);\n      if (l === -1)\n        throw new Error(\"Message is incomplete.\");\n      const u = l + 1;\n      t = String.fromCharCode.apply(null, Array.prototype.slice.call(a.slice(0, u))), n = a.byteLength > u ? a.slice(u).buffer : null;\n    } else {\n      const a = e, l = a.indexOf(b.RecordSeparator);\n      if (l === -1)\n        throw new Error(\"Message is incomplete.\");\n      const u = l + 1;\n      t = a.substring(0, u), n = a.length > u ? a.substring(u) : null;\n    }\n    const o = b.parse(t), r = JSON.parse(o[0]);\n    if (r.type)\n      throw new Error(\"Expected a handshake response from the server.\");\n    return [n, r];\n  }\n}\nvar h;\n(function(s) {\n  s[s.Invocation = 1] = \"Invocation\", s[s.StreamItem = 2] = \"StreamItem\", s[s.Completion = 3] = \"Completion\", s[s.StreamInvocation = 4] = \"StreamInvocation\", s[s.CancelInvocation = 5] = \"CancelInvocation\", s[s.Ping = 6] = \"Ping\", s[s.Close = 7] = \"Close\", s[s.Ack = 8] = \"Ack\", s[s.Sequence = 9] = \"Sequence\";\n})(h || (h = {}));\nclass _e {\n  constructor() {\n    this.observers = [];\n  }\n  next(e) {\n    for (const t of this.observers)\n      t.next(e);\n  }\n  error(e) {\n    for (const t of this.observers)\n      t.error && t.error(e);\n  }\n  complete() {\n    for (const e of this.observers)\n      e.complete && e.complete();\n  }\n  subscribe(e) {\n    return this.observers.push(e), new se(this, e);\n  }\n}\nclass fe {\n  constructor(e, t, n) {\n    this._bufferSize = 1e5, this._messages = [], this._totalMessageCount = 0, this._waitForSequenceMessage = !1, this._nextReceivingSequenceId = 1, this._latestReceivedSequenceId = 0, this._bufferedByteCount = 0, this._reconnectInProgress = !1, this._protocol = e, this._connection = t, this._bufferSize = n;\n  }\n  async _send(e) {\n    const t = this._protocol.writeMessage(e);\n    let n = Promise.resolve();\n    if (this._isInvocationMessage(e)) {\n      this._totalMessageCount++;\n      let o = () => {\n      }, r = () => {\n      };\n      k(t) ? this._bufferedByteCount += t.byteLength : this._bufferedByteCount += t.length, this._bufferedByteCount >= this._bufferSize && (n = new Promise((c, a) => {\n        o = c, r = a;\n      })), this._messages.push(new pe(t, this._totalMessageCount, o, r));\n    }\n    try {\n      this._reconnectInProgress || await this._connection.send(t);\n    } catch {\n      this._disconnected();\n    }\n    await n;\n  }\n  _ack(e) {\n    let t = -1;\n    for (let n = 0; n < this._messages.length; n++) {\n      const o = this._messages[n];\n      if (o._id <= e.sequenceId)\n        t = n, k(o._message) ? this._bufferedByteCount -= o._message.byteLength : this._bufferedByteCount -= o._message.length, o._resolver();\n      else if (this._bufferedByteCount < this._bufferSize)\n        o._resolver();\n      else\n        break;\n    }\n    t !== -1 && (this._messages = this._messages.slice(t + 1));\n  }\n  _shouldProcessMessage(e) {\n    if (this._waitForSequenceMessage)\n      return e.type !== h.Sequence ? !1 : (this._waitForSequenceMessage = !1, !0);\n    if (!this._isInvocationMessage(e))\n      return !0;\n    const t = this._nextReceivingSequenceId;\n    return this._nextReceivingSequenceId++, t <= this._latestReceivedSequenceId ? (t === this._latestReceivedSequenceId && this._ackTimer(), !1) : (this._latestReceivedSequenceId = t, this._ackTimer(), !0);\n  }\n  _resetSequence(e) {\n    if (e.sequenceId > this._nextReceivingSequenceId) {\n      this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\n      return;\n    }\n    this._nextReceivingSequenceId = e.sequenceId;\n  }\n  _disconnected() {\n    this._reconnectInProgress = !0, this._waitForSequenceMessage = !0;\n  }\n  async _resend() {\n    const e = this._messages.length !== 0 ? this._messages[0]._id : this._totalMessageCount + 1;\n    await this._connection.send(this._protocol.writeMessage({ type: h.Sequence, sequenceId: e }));\n    const t = this._messages;\n    for (const n of t)\n      await this._connection.send(n._message);\n    this._reconnectInProgress = !1;\n  }\n  _dispose(e) {\n    e ?? (e = new Error(\"Unable to reconnect to server.\"));\n    for (const t of this._messages)\n      t._rejector(e);\n  }\n  _isInvocationMessage(e) {\n    switch (e.type) {\n      case h.Invocation:\n      case h.StreamItem:\n      case h.Completion:\n      case h.StreamInvocation:\n      case h.CancelInvocation:\n        return !0;\n      case h.Close:\n      case h.Sequence:\n      case h.Ping:\n      case h.Ack:\n        return !1;\n    }\n  }\n  _ackTimer() {\n    this._ackTimerHandle === void 0 && (this._ackTimerHandle = setTimeout(async () => {\n      try {\n        this._reconnectInProgress || await this._connection.send(this._protocol.writeMessage({ type: h.Ack, sequenceId: this._latestReceivedSequenceId }));\n      } catch {\n      }\n      clearTimeout(this._ackTimerHandle), this._ackTimerHandle = void 0;\n    }, 1e3));\n  }\n}\nclass pe {\n  constructor(e, t, n, o) {\n    this._message = e, this._id = t, this._resolver = n, this._rejector = o;\n  }\n}\nconst me = 30 * 1e3, we = 15 * 1e3, be = 1e5;\nvar g;\n(function(s) {\n  s.Disconnected = \"Disconnected\", s.Connecting = \"Connecting\", s.Connected = \"Connected\", s.Disconnecting = \"Disconnecting\", s.Reconnecting = \"Reconnecting\";\n})(g || (g = {}));\nclass A {\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n  static create(e, t, n, o, r, c, a) {\n    return new A(e, t, n, o, r, c, a);\n  }\n  constructor(e, t, n, o, r, c, a) {\n    this._nextKeepAlive = 0, this._freezeEventListener = () => {\n      this._logger.log(i.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n    }, f.isRequired(e, \"connection\"), f.isRequired(t, \"logger\"), f.isRequired(n, \"protocol\"), this.serverTimeoutInMilliseconds = r ?? me, this.keepAliveIntervalInMilliseconds = c ?? we, this._statefulReconnectBufferSize = a ?? be, this._logger = t, this._protocol = n, this.connection = e, this._reconnectPolicy = o, this._handshakeProtocol = new ge(), this.connection.onreceive = (l) => this._processIncomingData(l), this.connection.onclose = (l) => this._connectionClosed(l), this._callbacks = {}, this._methods = {}, this._closedCallbacks = [], this._reconnectingCallbacks = [], this._reconnectedCallbacks = [], this._invocationId = 0, this._receivedHandshakeResponse = !1, this._connectionState = g.Disconnected, this._connectionStarted = !1, this._cachedPingMessage = this._protocol.writeMessage({ type: h.Ping });\n  }\n  /** Indicates the state of the {@link HubConnection} to the server. */\n  get state() {\n    return this._connectionState;\n  }\n  /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\n   *  in the disconnected state or if the negotiation step was skipped.\n   */\n  get connectionId() {\n    return this.connection && this.connection.connectionId || null;\n  }\n  /** Indicates the url of the {@link HubConnection} to the server. */\n  get baseUrl() {\n    return this.connection.baseUrl || \"\";\n  }\n  /**\n   * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\n   * Reconnecting states.\n   * @param {string} url The url to connect to.\n   */\n  set baseUrl(e) {\n    if (this._connectionState !== g.Disconnected && this._connectionState !== g.Reconnecting)\n      throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n    if (!e)\n      throw new Error(\"The HubConnection url must be a valid url.\");\n    this.connection.baseUrl = e;\n  }\n  /** Starts the connection.\n   *\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\n   */\n  start() {\n    return this._startPromise = this._startWithStateTransitions(), this._startPromise;\n  }\n  async _startWithStateTransitions() {\n    if (this._connectionState !== g.Disconnected)\n      return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\n    this._connectionState = g.Connecting, this._logger.log(i.Debug, \"Starting HubConnection.\");\n    try {\n      await this._startInternal(), _.isBrowser && window.document.addEventListener(\"freeze\", this._freezeEventListener), this._connectionState = g.Connected, this._connectionStarted = !0, this._logger.log(i.Debug, \"HubConnection connected successfully.\");\n    } catch (e) {\n      return this._connectionState = g.Disconnected, this._logger.log(i.Debug, `HubConnection failed to start successfully because of error '${e}'.`), Promise.reject(e);\n    }\n  }\n  async _startInternal() {\n    this._stopDuringStartError = void 0, this._receivedHandshakeResponse = !1;\n    const e = new Promise((t, n) => {\n      this._handshakeResolver = t, this._handshakeRejecter = n;\n    });\n    await this.connection.start(this._protocol.transferFormat);\n    try {\n      let t = this._protocol.version;\n      this.connection.features.reconnect || (t = 1);\n      const n = {\n        protocol: this._protocol.name,\n        version: t\n      };\n      if (this._logger.log(i.Debug, \"Sending handshake request.\"), await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(n)), this._logger.log(i.Information, `Using HubProtocol '${this._protocol.name}'.`), this._cleanupTimeout(), this._resetTimeoutPeriod(), this._resetKeepAliveInterval(), await e, this._stopDuringStartError)\n        throw this._stopDuringStartError;\n      (this.connection.features.reconnect || !1) && (this._messageBuffer = new fe(this._protocol, this.connection, this._statefulReconnectBufferSize), this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer), this.connection.features.resend = () => {\n        if (this._messageBuffer)\n          return this._messageBuffer._resend();\n      }), this.connection.features.inherentKeepAlive || await this._sendMessage(this._cachedPingMessage);\n    } catch (t) {\n      throw this._logger.log(i.Debug, `Hub handshake failed with error '${t}' during start(). Stopping HubConnection.`), this._cleanupTimeout(), this._cleanupPingTimer(), await this.connection.stop(t), t;\n    }\n  }\n  /** Stops the connection.\n   *\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\n   */\n  async stop() {\n    const e = this._startPromise;\n    this.connection.features.reconnect = !1, this._stopPromise = this._stopInternal(), await this._stopPromise;\n    try {\n      await e;\n    } catch {\n    }\n  }\n  _stopInternal(e) {\n    if (this._connectionState === g.Disconnected)\n      return this._logger.log(i.Debug, `Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`), Promise.resolve();\n    if (this._connectionState === g.Disconnecting)\n      return this._logger.log(i.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise;\n    const t = this._connectionState;\n    return this._connectionState = g.Disconnecting, this._logger.log(i.Debug, \"Stopping HubConnection.\"), this._reconnectDelayHandle ? (this._logger.log(i.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\"), clearTimeout(this._reconnectDelayHandle), this._reconnectDelayHandle = void 0, this._completeClose(), Promise.resolve()) : (t === g.Connected && this._sendCloseMessage(), this._cleanupTimeout(), this._cleanupPingTimer(), this._stopDuringStartError = e || new C(\"The connection was stopped before the hub handshake could complete.\"), this.connection.stop(e));\n  }\n  async _sendCloseMessage() {\n    try {\n      await this._sendWithProtocol(this._createCloseMessage());\n    } catch {\n    }\n  }\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\n   *\n   * @typeparam T The type of the items returned by the server.\n   * @param {string} methodName The name of the server method to invoke.\n   * @param {any[]} args The arguments used to invoke the server method.\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\n   */\n  stream(e, ...t) {\n    const [n, o] = this._replaceStreamingParams(t), r = this._createStreamInvocation(e, t, o);\n    let c;\n    const a = new _e();\n    return a.cancelCallback = () => {\n      const l = this._createCancelInvocation(r.invocationId);\n      return delete this._callbacks[r.invocationId], c.then(() => this._sendWithProtocol(l));\n    }, this._callbacks[r.invocationId] = (l, u) => {\n      if (u) {\n        a.error(u);\n        return;\n      } else l && (l.type === h.Completion ? l.error ? a.error(new Error(l.error)) : a.complete() : a.next(l.item));\n    }, c = this._sendWithProtocol(r).catch((l) => {\n      a.error(l), delete this._callbacks[r.invocationId];\n    }), this._launchStreams(n, c), a;\n  }\n  _sendMessage(e) {\n    return this._resetKeepAliveInterval(), this.connection.send(e);\n  }\n  /**\n   * Sends a js object to the server.\n   * @param message The js object to serialize and send.\n   */\n  _sendWithProtocol(e) {\n    return this._messageBuffer ? this._messageBuffer._send(e) : this._sendMessage(this._protocol.writeMessage(e));\n  }\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\n   *\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\n   * be processing the invocation.\n   *\n   * @param {string} methodName The name of the server method to invoke.\n   * @param {any[]} args The arguments used to invoke the server method.\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\n   */\n  send(e, ...t) {\n    const [n, o] = this._replaceStreamingParams(t), r = this._sendWithProtocol(this._createInvocation(e, t, !0, o));\n    return this._launchStreams(n, r), r;\n  }\n  /** Invokes a hub method on the server using the specified name and arguments.\n   *\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\n   * resolving the Promise.\n   *\n   * @typeparam T The expected return type.\n   * @param {string} methodName The name of the server method to invoke.\n   * @param {any[]} args The arguments used to invoke the server method.\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\n   */\n  invoke(e, ...t) {\n    const [n, o] = this._replaceStreamingParams(t), r = this._createInvocation(e, t, !1, o);\n    return new Promise((a, l) => {\n      this._callbacks[r.invocationId] = (d, S) => {\n        if (S) {\n          l(S);\n          return;\n        } else d && (d.type === h.Completion ? d.error ? l(new Error(d.error)) : a(d.result) : l(new Error(`Unexpected message type: ${d.type}`)));\n      };\n      const u = this._sendWithProtocol(r).catch((d) => {\n        l(d), delete this._callbacks[r.invocationId];\n      });\n      this._launchStreams(n, u);\n    });\n  }\n  on(e, t) {\n    !e || !t || (e = e.toLowerCase(), this._methods[e] || (this._methods[e] = []), this._methods[e].indexOf(t) === -1 && this._methods[e].push(t));\n  }\n  off(e, t) {\n    if (!e)\n      return;\n    e = e.toLowerCase();\n    const n = this._methods[e];\n    if (n)\n      if (t) {\n        const o = n.indexOf(t);\n        o !== -1 && (n.splice(o, 1), n.length === 0 && delete this._methods[e]);\n      } else\n        delete this._methods[e];\n  }\n  /** Registers a handler that will be invoked when the connection is closed.\n   *\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\n   */\n  onclose(e) {\n    e && this._closedCallbacks.push(e);\n  }\n  /** Registers a handler that will be invoked when the connection starts reconnecting.\n   *\n   * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\n   */\n  onreconnecting(e) {\n    e && this._reconnectingCallbacks.push(e);\n  }\n  /** Registers a handler that will be invoked when the connection successfully reconnects.\n   *\n   * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\n   */\n  onreconnected(e) {\n    e && this._reconnectedCallbacks.push(e);\n  }\n  _processIncomingData(e) {\n    if (this._cleanupTimeout(), this._receivedHandshakeResponse || (e = this._processHandshakeResponse(e), this._receivedHandshakeResponse = !0), e) {\n      const t = this._protocol.parseMessages(e, this._logger);\n      for (const n of t)\n        if (!(this._messageBuffer && !this._messageBuffer._shouldProcessMessage(n)))\n          switch (n.type) {\n            case h.Invocation:\n              this._invokeClientMethod(n).catch((o) => {\n                this._logger.log(i.Error, `Invoke client method threw error: ${$(o)}`);\n              });\n              break;\n            case h.StreamItem:\n            case h.Completion: {\n              const o = this._callbacks[n.invocationId];\n              if (o) {\n                n.type === h.Completion && delete this._callbacks[n.invocationId];\n                try {\n                  o(n);\n                } catch (r) {\n                  this._logger.log(i.Error, `Stream callback threw error: ${$(r)}`);\n                }\n              }\n              break;\n            }\n            case h.Ping:\n              break;\n            case h.Close: {\n              this._logger.log(i.Information, \"Close message received from server.\");\n              const o = n.error ? new Error(\"Server returned an error on close: \" + n.error) : void 0;\n              n.allowReconnect === !0 ? this.connection.stop(o) : this._stopPromise = this._stopInternal(o);\n              break;\n            }\n            case h.Ack:\n              this._messageBuffer && this._messageBuffer._ack(n);\n              break;\n            case h.Sequence:\n              this._messageBuffer && this._messageBuffer._resetSequence(n);\n              break;\n            default:\n              this._logger.log(i.Warning, `Invalid message type: ${n.type}.`);\n              break;\n          }\n    }\n    this._resetTimeoutPeriod();\n  }\n  _processHandshakeResponse(e) {\n    let t, n;\n    try {\n      [n, t] = this._handshakeProtocol.parseHandshakeResponse(e);\n    } catch (o) {\n      const r = \"Error parsing handshake response: \" + o;\n      this._logger.log(i.Error, r);\n      const c = new Error(r);\n      throw this._handshakeRejecter(c), c;\n    }\n    if (t.error) {\n      const o = \"Server returned handshake error: \" + t.error;\n      this._logger.log(i.Error, o);\n      const r = new Error(o);\n      throw this._handshakeRejecter(r), r;\n    } else\n      this._logger.log(i.Debug, \"Server handshake complete.\");\n    return this._handshakeResolver(), n;\n  }\n  _resetKeepAliveInterval() {\n    this.connection.features.inherentKeepAlive || (this._nextKeepAlive = (/* @__PURE__ */ new Date()).getTime() + this.keepAliveIntervalInMilliseconds, this._cleanupPingTimer());\n  }\n  _resetTimeoutPeriod() {\n    if ((!this.connection.features || !this.connection.features.inherentKeepAlive) && (this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), this._pingServerHandle === void 0)) {\n      let e = this._nextKeepAlive - (/* @__PURE__ */ new Date()).getTime();\n      e < 0 && (e = 0), this._pingServerHandle = setTimeout(async () => {\n        if (this._connectionState === g.Connected)\n          try {\n            await this._sendMessage(this._cachedPingMessage);\n          } catch {\n            this._cleanupPingTimer();\n          }\n      }, e);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  serverTimeout() {\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  }\n  async _invokeClientMethod(e) {\n    const t = e.target.toLowerCase(), n = this._methods[t];\n    if (!n) {\n      this._logger.log(i.Warning, `No client method with the name '${t}' found.`), e.invocationId && (this._logger.log(i.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), await this._sendWithProtocol(this._createCompletionMessage(e.invocationId, \"Client didn't provide a result.\", null)));\n      return;\n    }\n    const o = n.slice(), r = !!e.invocationId;\n    let c, a, l;\n    for (const u of o)\n      try {\n        const d = c;\n        c = await u.apply(this, e.arguments), r && c && d && (this._logger.log(i.Error, `Multiple results provided for '${t}'. Sending error to server.`), l = this._createCompletionMessage(e.invocationId, \"Client provided multiple results.\", null)), a = void 0;\n      } catch (d) {\n        a = d, this._logger.log(i.Error, `A callback for the method '${t}' threw error '${d}'.`);\n      }\n    l ? await this._sendWithProtocol(l) : r ? (a ? l = this._createCompletionMessage(e.invocationId, `${a}`, null) : c !== void 0 ? l = this._createCompletionMessage(e.invocationId, null, c) : (this._logger.log(i.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), l = this._createCompletionMessage(e.invocationId, \"Client didn't provide a result.\", null)), await this._sendWithProtocol(l)) : c && this._logger.log(i.Error, `Result given for '${t}' method but server is not expecting a result.`);\n  }\n  _connectionClosed(e) {\n    this._logger.log(i.Debug, `HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`), this._stopDuringStartError = this._stopDuringStartError || e || new C(\"The underlying connection was closed before the hub handshake could complete.\"), this._handshakeResolver && this._handshakeResolver(), this._cancelCallbacksWithError(e || new Error(\"Invocation canceled due to the underlying connection being closed.\")), this._cleanupTimeout(), this._cleanupPingTimer(), this._connectionState === g.Disconnecting ? this._completeClose(e) : this._connectionState === g.Connected && this._reconnectPolicy ? this._reconnect(e) : this._connectionState === g.Connected && this._completeClose(e);\n  }\n  _completeClose(e) {\n    if (this._connectionStarted) {\n      this._connectionState = g.Disconnected, this._connectionStarted = !1, this._messageBuffer && (this._messageBuffer._dispose(e ?? new Error(\"Connection closed.\")), this._messageBuffer = void 0), _.isBrowser && window.document.removeEventListener(\"freeze\", this._freezeEventListener);\n      try {\n        this._closedCallbacks.forEach((t) => t.apply(this, [e]));\n      } catch (t) {\n        this._logger.log(i.Error, `An onclose callback called with error '${e}' threw error '${t}'.`);\n      }\n    }\n  }\n  async _reconnect(e) {\n    const t = Date.now();\n    let n = 0, o = e !== void 0 ? e : new Error(\"Attempting to reconnect due to a unknown error.\"), r = this._getNextRetryDelay(n++, 0, o);\n    if (r === null) {\n      this._logger.log(i.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\"), this._completeClose(e);\n      return;\n    }\n    if (this._connectionState = g.Reconnecting, e ? this._logger.log(i.Information, `Connection reconnecting because of error '${e}'.`) : this._logger.log(i.Information, \"Connection reconnecting.\"), this._reconnectingCallbacks.length !== 0) {\n      try {\n        this._reconnectingCallbacks.forEach((c) => c.apply(this, [e]));\n      } catch (c) {\n        this._logger.log(i.Error, `An onreconnecting callback called with error '${e}' threw error '${c}'.`);\n      }\n      if (this._connectionState !== g.Reconnecting) {\n        this._logger.log(i.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n        return;\n      }\n    }\n    for (; r !== null; ) {\n      if (this._logger.log(i.Information, `Reconnect attempt number ${n} will start in ${r} ms.`), await new Promise((c) => {\n        this._reconnectDelayHandle = setTimeout(c, r);\n      }), this._reconnectDelayHandle = void 0, this._connectionState !== g.Reconnecting) {\n        this._logger.log(i.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n        return;\n      }\n      try {\n        if (await this._startInternal(), this._connectionState = g.Connected, this._logger.log(i.Information, \"HubConnection reconnected successfully.\"), this._reconnectedCallbacks.length !== 0)\n          try {\n            this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\n          } catch (c) {\n            this._logger.log(i.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${c}'.`);\n          }\n        return;\n      } catch (c) {\n        if (this._logger.log(i.Information, `Reconnect attempt failed because of error '${c}'.`), this._connectionState !== g.Reconnecting) {\n          this._logger.log(i.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`), this._connectionState === g.Disconnecting && this._completeClose();\n          return;\n        }\n        o = c instanceof Error ? c : new Error(c.toString()), r = this._getNextRetryDelay(n++, Date.now() - t, o);\n      }\n    }\n    this._logger.log(i.Information, `Reconnect retries have been exhausted after ${Date.now() - t} ms and ${n} failed attempts. Connection disconnecting.`), this._completeClose();\n  }\n  _getNextRetryDelay(e, t, n) {\n    try {\n      return this._reconnectPolicy.nextRetryDelayInMilliseconds({\n        elapsedMilliseconds: t,\n        previousRetryCount: e,\n        retryReason: n\n      });\n    } catch (o) {\n      return this._logger.log(i.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${o}'.`), null;\n    }\n  }\n  _cancelCallbacksWithError(e) {\n    const t = this._callbacks;\n    this._callbacks = {}, Object.keys(t).forEach((n) => {\n      const o = t[n];\n      try {\n        o(null, e);\n      } catch (r) {\n        this._logger.log(i.Error, `Stream 'error' callback called with '${e}' threw error: ${$(r)}`);\n      }\n    });\n  }\n  _cleanupPingTimer() {\n    this._pingServerHandle && (clearTimeout(this._pingServerHandle), this._pingServerHandle = void 0);\n  }\n  _cleanupTimeout() {\n    this._timeoutHandle && clearTimeout(this._timeoutHandle);\n  }\n  _createInvocation(e, t, n, o) {\n    if (n)\n      return o.length !== 0 ? {\n        arguments: t,\n        streamIds: o,\n        target: e,\n        type: h.Invocation\n      } : {\n        arguments: t,\n        target: e,\n        type: h.Invocation\n      };\n    {\n      const r = this._invocationId;\n      return this._invocationId++, o.length !== 0 ? {\n        arguments: t,\n        invocationId: r.toString(),\n        streamIds: o,\n        target: e,\n        type: h.Invocation\n      } : {\n        arguments: t,\n        invocationId: r.toString(),\n        target: e,\n        type: h.Invocation\n      };\n    }\n  }\n  _launchStreams(e, t) {\n    if (e.length !== 0) {\n      t || (t = Promise.resolve());\n      for (const n in e)\n        e[n].subscribe({\n          complete: () => {\n            t = t.then(() => this._sendWithProtocol(this._createCompletionMessage(n)));\n          },\n          error: (o) => {\n            let r;\n            o instanceof Error ? r = o.message : o && o.toString ? r = o.toString() : r = \"Unknown error\", t = t.then(() => this._sendWithProtocol(this._createCompletionMessage(n, r)));\n          },\n          next: (o) => {\n            t = t.then(() => this._sendWithProtocol(this._createStreamItemMessage(n, o)));\n          }\n        });\n    }\n  }\n  _replaceStreamingParams(e) {\n    const t = [], n = [];\n    for (let o = 0; o < e.length; o++) {\n      const r = e[o];\n      if (this._isObservable(r)) {\n        const c = this._invocationId;\n        this._invocationId++, t[c] = r, n.push(c.toString()), e.splice(o, 1);\n      }\n    }\n    return [t, n];\n  }\n  _isObservable(e) {\n    return e && e.subscribe && typeof e.subscribe == \"function\";\n  }\n  _createStreamInvocation(e, t, n) {\n    const o = this._invocationId;\n    return this._invocationId++, n.length !== 0 ? {\n      arguments: t,\n      invocationId: o.toString(),\n      streamIds: n,\n      target: e,\n      type: h.StreamInvocation\n    } : {\n      arguments: t,\n      invocationId: o.toString(),\n      target: e,\n      type: h.StreamInvocation\n    };\n  }\n  _createCancelInvocation(e) {\n    return {\n      invocationId: e,\n      type: h.CancelInvocation\n    };\n  }\n  _createStreamItemMessage(e, t) {\n    return {\n      invocationId: e,\n      item: t,\n      type: h.StreamItem\n    };\n  }\n  _createCompletionMessage(e, t, n) {\n    return t ? {\n      error: t,\n      invocationId: e,\n      type: h.Completion\n    } : {\n      invocationId: e,\n      result: n,\n      type: h.Completion\n    };\n  }\n  _createCloseMessage() {\n    return { type: h.Close };\n  }\n}\nconst Ce = [0, 2e3, 1e4, 3e4, null];\nclass L {\n  constructor(e) {\n    this._retryDelays = e !== void 0 ? [...e, null] : Ce;\n  }\n  nextRetryDelayInMilliseconds(e) {\n    return this._retryDelays[e.previousRetryCount];\n  }\n}\nclass v {\n}\nv.Authorization = \"Authorization\";\nv.Cookie = \"Cookie\";\nclass Se extends D {\n  constructor(e, t) {\n    super(), this._innerClient = e, this._accessTokenFactory = t;\n  }\n  async send(e) {\n    let t = !0;\n    this._accessTokenFactory && (!this._accessToken || e.url && e.url.indexOf(\"/negotiate?\") > 0) && (t = !1, this._accessToken = await this._accessTokenFactory()), this._setAuthorizationHeader(e);\n    const n = await this._innerClient.send(e);\n    return t && n.statusCode === 401 && this._accessTokenFactory ? (this._accessToken = await this._accessTokenFactory(), this._setAuthorizationHeader(e), await this._innerClient.send(e)) : n;\n  }\n  _setAuthorizationHeader(e) {\n    e.headers || (e.headers = {}), this._accessToken ? e.headers[v.Authorization] = `Bearer ${this._accessToken}` : this._accessTokenFactory && e.headers[v.Authorization] && delete e.headers[v.Authorization];\n  }\n  getCookieString(e) {\n    return this._innerClient.getCookieString(e);\n  }\n}\nvar p;\n(function(s) {\n  s[s.None = 0] = \"None\", s[s.WebSockets = 1] = \"WebSockets\", s[s.ServerSentEvents = 2] = \"ServerSentEvents\", s[s.LongPolling = 4] = \"LongPolling\";\n})(p || (p = {}));\nvar m;\n(function(s) {\n  s[s.Text = 1] = \"Text\", s[s.Binary = 2] = \"Binary\";\n})(m || (m = {}));\nlet ye = class {\n  constructor() {\n    this._isAborted = !1, this.onabort = null;\n  }\n  abort() {\n    this._isAborted || (this._isAborted = !0, this.onabort && this.onabort());\n  }\n  get signal() {\n    return this;\n  }\n  get aborted() {\n    return this._isAborted;\n  }\n};\nclass U {\n  // This is an internal type, not exported from 'index' so this is really just internal.\n  get pollAborted() {\n    return this._pollAbort.aborted;\n  }\n  constructor(e, t, n) {\n    this._httpClient = e, this._logger = t, this._pollAbort = new ye(), this._options = n, this._running = !1, this.onreceive = null, this.onclose = null;\n  }\n  async connect(e, t) {\n    if (f.isRequired(e, \"url\"), f.isRequired(t, \"transferFormat\"), f.isIn(t, m, \"transferFormat\"), this._url = e, this._logger.log(i.Trace, \"(LongPolling transport) Connecting.\"), t === m.Binary && typeof XMLHttpRequest < \"u\" && typeof new XMLHttpRequest().responseType != \"string\")\n      throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n    const [n, o] = E(), r = { [n]: o, ...this._options.headers }, c = {\n      abortSignal: this._pollAbort.signal,\n      headers: r,\n      timeout: 1e5,\n      withCredentials: this._options.withCredentials\n    };\n    t === m.Binary && (c.responseType = \"arraybuffer\");\n    const a = `${e}&_=${Date.now()}`;\n    this._logger.log(i.Trace, `(LongPolling transport) polling: ${a}.`);\n    const l = await this._httpClient.get(a, c);\n    l.statusCode !== 200 ? (this._logger.log(i.Error, `(LongPolling transport) Unexpected response code: ${l.statusCode}.`), this._closeError = new y(l.statusText || \"\", l.statusCode), this._running = !1) : this._running = !0, this._receiving = this._poll(this._url, c);\n  }\n  async _poll(e, t) {\n    try {\n      for (; this._running; )\n        try {\n          const n = `${e}&_=${Date.now()}`;\n          this._logger.log(i.Trace, `(LongPolling transport) polling: ${n}.`);\n          const o = await this._httpClient.get(n, t);\n          o.statusCode === 204 ? (this._logger.log(i.Information, \"(LongPolling transport) Poll terminated by server.\"), this._running = !1) : o.statusCode !== 200 ? (this._logger.log(i.Error, `(LongPolling transport) Unexpected response code: ${o.statusCode}.`), this._closeError = new y(o.statusText || \"\", o.statusCode), this._running = !1) : o.content ? (this._logger.log(i.Trace, `(LongPolling transport) data received. ${T(o.content, this._options.logMessageContent)}.`), this.onreceive && this.onreceive(o.content)) : this._logger.log(i.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n        } catch (n) {\n          this._running ? n instanceof x ? this._logger.log(i.Trace, \"(LongPolling transport) Poll timed out, reissuing.\") : (this._closeError = n, this._running = !1) : this._logger.log(i.Trace, `(LongPolling transport) Poll errored after shutdown: ${n.message}`);\n        }\n    } finally {\n      this._logger.log(i.Trace, \"(LongPolling transport) Polling complete.\"), this.pollAborted || this._raiseOnClose();\n    }\n  }\n  async send(e) {\n    return this._running ? j(this._logger, \"LongPolling\", this._httpClient, this._url, e, this._options) : Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n  }\n  async stop() {\n    this._logger.log(i.Trace, \"(LongPolling transport) Stopping polling.\"), this._running = !1, this._pollAbort.abort();\n    try {\n      await this._receiving, this._logger.log(i.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\n      const e = {}, [t, n] = E();\n      e[t] = n;\n      const o = {\n        headers: { ...e, ...this._options.headers },\n        timeout: this._options.timeout,\n        withCredentials: this._options.withCredentials\n      };\n      let r;\n      try {\n        await this._httpClient.delete(this._url, o);\n      } catch (c) {\n        r = c;\n      }\n      r ? r instanceof y && (r.statusCode === 404 ? this._logger.log(i.Trace, \"(LongPolling transport) A 404 response was returned from sending a DELETE request.\") : this._logger.log(i.Trace, `(LongPolling transport) Error sending a DELETE request: ${r}`)) : this._logger.log(i.Trace, \"(LongPolling transport) DELETE request accepted.\");\n    } finally {\n      this._logger.log(i.Trace, \"(LongPolling transport) Stop finished.\"), this._raiseOnClose();\n    }\n  }\n  _raiseOnClose() {\n    if (this.onclose) {\n      let e = \"(LongPolling transport) Firing onclose event.\";\n      this._closeError && (e += \" Error: \" + this._closeError), this._logger.log(i.Trace, e), this.onclose(this._closeError);\n    }\n  }\n}\nclass ve {\n  constructor(e, t, n, o) {\n    this._httpClient = e, this._accessToken = t, this._logger = n, this._options = o, this.onreceive = null, this.onclose = null;\n  }\n  async connect(e, t) {\n    return f.isRequired(e, \"url\"), f.isRequired(t, \"transferFormat\"), f.isIn(t, m, \"transferFormat\"), this._logger.log(i.Trace, \"(SSE transport) Connecting.\"), this._url = e, this._accessToken && (e += (e.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`), new Promise((n, o) => {\n      let r = !1;\n      if (t !== m.Text) {\n        o(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n        return;\n      }\n      let c;\n      if (_.isBrowser || _.isWebWorker)\n        c = new this._options.EventSource(e, { withCredentials: this._options.withCredentials });\n      else {\n        const a = this._httpClient.getCookieString(e), l = {};\n        l.Cookie = a;\n        const [u, d] = E();\n        l[u] = d, c = new this._options.EventSource(e, { withCredentials: this._options.withCredentials, headers: { ...l, ...this._options.headers } });\n      }\n      try {\n        c.onmessage = (a) => {\n          if (this.onreceive)\n            try {\n              this._logger.log(i.Trace, `(SSE transport) data received. ${T(a.data, this._options.logMessageContent)}.`), this.onreceive(a.data);\n            } catch (l) {\n              this._close(l);\n              return;\n            }\n        }, c.onerror = (a) => {\n          r ? this._close() : o(new Error(\"EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.\"));\n        }, c.onopen = () => {\n          this._logger.log(i.Information, `SSE connected to ${this._url}`), this._eventSource = c, r = !0, n();\n        };\n      } catch (a) {\n        o(a);\n        return;\n      }\n    });\n  }\n  async send(e) {\n    return this._eventSource ? j(this._logger, \"SSE\", this._httpClient, this._url, e, this._options) : Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n  }\n  stop() {\n    return this._close(), Promise.resolve();\n  }\n  _close(e) {\n    this._eventSource && (this._eventSource.close(), this._eventSource = void 0, this.onclose && this.onclose(e));\n  }\n}\nclass ke {\n  constructor(e, t, n, o, r, c) {\n    this._logger = n, this._accessTokenFactory = t, this._logMessageContent = o, this._webSocketConstructor = r, this._httpClient = e, this.onreceive = null, this.onclose = null, this._headers = c;\n  }\n  async connect(e, t) {\n    f.isRequired(e, \"url\"), f.isRequired(t, \"transferFormat\"), f.isIn(t, m, \"transferFormat\"), this._logger.log(i.Trace, \"(WebSockets transport) Connecting.\");\n    let n;\n    return this._accessTokenFactory && (n = await this._accessTokenFactory()), new Promise((o, r) => {\n      e = e.replace(/^http/, \"ws\");\n      let c;\n      const a = this._httpClient.getCookieString(e);\n      let l = !1;\n      if (_.isNode || _.isReactNative) {\n        const u = {}, [d, S] = E();\n        u[d] = S, n && (u[v.Authorization] = `Bearer ${n}`), a && (u[v.Cookie] = a), c = new this._webSocketConstructor(e, void 0, {\n          headers: { ...u, ...this._headers }\n        });\n      } else\n        n && (e += (e.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(n)}`);\n      c || (c = new this._webSocketConstructor(e)), t === m.Binary && (c.binaryType = \"arraybuffer\"), c.onopen = (u) => {\n        this._logger.log(i.Information, `WebSocket connected to ${e}.`), this._webSocket = c, l = !0, o();\n      }, c.onerror = (u) => {\n        let d = null;\n        typeof ErrorEvent < \"u\" && u instanceof ErrorEvent ? d = u.error : d = \"There was an error with the transport\", this._logger.log(i.Information, `(WebSockets transport) ${d}.`);\n      }, c.onmessage = (u) => {\n        if (this._logger.log(i.Trace, `(WebSockets transport) data received. ${T(u.data, this._logMessageContent)}.`), this.onreceive)\n          try {\n            this.onreceive(u.data);\n          } catch (d) {\n            this._close(d);\n            return;\n          }\n      }, c.onclose = (u) => {\n        if (l)\n          this._close(u);\n        else {\n          let d = null;\n          typeof ErrorEvent < \"u\" && u instanceof ErrorEvent ? d = u.error : d = \"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.\", r(new Error(d));\n        }\n      };\n    });\n  }\n  send(e) {\n    return this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN ? (this._logger.log(i.Trace, `(WebSockets transport) sending data. ${T(e, this._logMessageContent)}.`), this._webSocket.send(e), Promise.resolve()) : Promise.reject(\"WebSocket is not in the OPEN state\");\n  }\n  stop() {\n    return this._webSocket && this._close(void 0), Promise.resolve();\n  }\n  _close(e) {\n    this._webSocket && (this._webSocket.onclose = () => {\n    }, this._webSocket.onmessage = () => {\n    }, this._webSocket.onerror = () => {\n    }, this._webSocket.close(), this._webSocket = void 0), this._logger.log(i.Trace, \"(WebSockets transport) socket closed.\"), this.onclose && (this._isCloseEvent(e) && (e.wasClean === !1 || e.code !== 1e3) ? this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason || \"no reason given\"}).`)) : e instanceof Error ? this.onclose(e) : this.onclose());\n  }\n  _isCloseEvent(e) {\n    return e && typeof e.wasClean == \"boolean\" && typeof e.code == \"number\";\n  }\n}\nconst O = 100;\nclass Ee {\n  constructor(e, t = {}) {\n    if (this._stopPromiseResolver = () => {\n    }, this.features = {}, this._negotiateVersion = 1, f.isRequired(e, \"url\"), this._logger = oe(t.logger), this.baseUrl = this._resolveUrl(e), t = t || {}, t.logMessageContent = t.logMessageContent === void 0 ? !1 : t.logMessageContent, typeof t.withCredentials == \"boolean\" || t.withCredentials === void 0)\n      t.withCredentials = t.withCredentials === void 0 ? !0 : t.withCredentials;\n    else\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    t.timeout = t.timeout === void 0 ? 100 * 1e3 : t.timeout;\n    let n = null, o = null;\n    if (_.isNode && typeof require < \"u\") {\n      const r = typeof __webpack_require__ == \"function\" ? __non_webpack_require__ : require;\n      n = r(\"ws\"), o = r(\"eventsource\");\n    }\n    !_.isNode && typeof WebSocket < \"u\" && !t.WebSocket ? t.WebSocket = WebSocket : _.isNode && !t.WebSocket && n && (t.WebSocket = n), !_.isNode && typeof EventSource < \"u\" && !t.EventSource ? t.EventSource = EventSource : _.isNode && !t.EventSource && typeof o < \"u\" && (t.EventSource = o), this._httpClient = new Se(t.httpClient || new de(this._logger), t.accessTokenFactory), this._connectionState = \"Disconnected\", this._connectionStarted = !1, this._options = t, this.onreceive = null, this.onclose = null;\n  }\n  async start(e) {\n    if (e = e || m.Binary, f.isIn(e, m, \"transferFormat\"), this._logger.log(i.Debug, `Starting connection with transfer format '${m[e]}'.`), this._connectionState !== \"Disconnected\")\n      return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\n    if (this._connectionState = \"Connecting\", this._startInternalPromise = this._startInternal(e), await this._startInternalPromise, this._connectionState === \"Disconnecting\") {\n      const t = \"Failed to start the HttpConnection before stop() was called.\";\n      return this._logger.log(i.Error, t), await this._stopPromise, Promise.reject(new C(t));\n    } else if (this._connectionState !== \"Connected\") {\n      const t = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n      return this._logger.log(i.Error, t), Promise.reject(new C(t));\n    }\n    this._connectionStarted = !0;\n  }\n  send(e) {\n    return this._connectionState !== \"Connected\" ? Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\")) : (this._sendQueue || (this._sendQueue = new M(this.transport)), this._sendQueue.send(e));\n  }\n  async stop(e) {\n    if (this._connectionState === \"Disconnected\")\n      return this._logger.log(i.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`), Promise.resolve();\n    if (this._connectionState === \"Disconnecting\")\n      return this._logger.log(i.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise;\n    this._connectionState = \"Disconnecting\", this._stopPromise = new Promise((t) => {\n      this._stopPromiseResolver = t;\n    }), await this._stopInternal(e), await this._stopPromise;\n  }\n  async _stopInternal(e) {\n    this._stopError = e;\n    try {\n      await this._startInternalPromise;\n    } catch {\n    }\n    if (this.transport) {\n      try {\n        await this.transport.stop();\n      } catch (t) {\n        this._logger.log(i.Error, `HttpConnection.transport.stop() threw error '${t}'.`), this._stopConnection();\n      }\n      this.transport = void 0;\n    } else\n      this._logger.log(i.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n  }\n  async _startInternal(e) {\n    let t = this.baseUrl;\n    this._accessTokenFactory = this._options.accessTokenFactory, this._httpClient._accessTokenFactory = this._accessTokenFactory;\n    try {\n      if (this._options.skipNegotiation)\n        if (this._options.transport === p.WebSockets)\n          this.transport = this._constructTransport(p.WebSockets), await this._startTransport(t, e);\n        else\n          throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n      else {\n        let n = null, o = 0;\n        do {\n          if (n = await this._getNegotiationResponse(t), this._connectionState === \"Disconnecting\" || this._connectionState === \"Disconnected\")\n            throw new C(\"The connection was stopped during negotiation.\");\n          if (n.error)\n            throw new Error(n.error);\n          if (n.ProtocolVersion)\n            throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n          if (n.url && (t = n.url), n.accessToken) {\n            const r = n.accessToken;\n            this._accessTokenFactory = () => r, this._httpClient._accessToken = r, this._httpClient._accessTokenFactory = void 0;\n          }\n          o++;\n        } while (n.url && o < O);\n        if (o === O && n.url)\n          throw new Error(\"Negotiate redirection limit exceeded.\");\n        await this._createTransport(t, this._options.transport, n, e);\n      }\n      this.transport instanceof U && (this.features.inherentKeepAlive = !0), this._connectionState === \"Connecting\" && (this._logger.log(i.Debug, \"The HttpConnection connected successfully.\"), this._connectionState = \"Connected\");\n    } catch (n) {\n      return this._logger.log(i.Error, \"Failed to start the connection: \" + n), this._connectionState = \"Disconnected\", this.transport = void 0, this._stopPromiseResolver(), Promise.reject(n);\n    }\n  }\n  async _getNegotiationResponse(e) {\n    const t = {}, [n, o] = E();\n    t[n] = o;\n    const r = this._resolveNegotiateUrl(e);\n    this._logger.log(i.Debug, `Sending negotiation request: ${r}.`);\n    try {\n      const c = await this._httpClient.post(r, {\n        content: \"\",\n        headers: { ...t, ...this._options.headers },\n        timeout: this._options.timeout,\n        withCredentials: this._options.withCredentials\n      });\n      if (c.statusCode !== 200)\n        return Promise.reject(new Error(`Unexpected status code returned from negotiate '${c.statusCode}'`));\n      const a = JSON.parse(c.content);\n      return (!a.negotiateVersion || a.negotiateVersion < 1) && (a.connectionToken = a.connectionId), a.useStatefulReconnect && this._options._useStatefulReconnect !== !0 ? Promise.reject(new W(\"Client didn't negotiate Stateful Reconnect but the server did.\")) : a;\n    } catch (c) {\n      let a = \"Failed to complete negotiation with the server: \" + c;\n      return c instanceof y && c.statusCode === 404 && (a = a + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\"), this._logger.log(i.Error, a), Promise.reject(new W(a));\n    }\n  }\n  _createConnectUrl(e, t) {\n    return t ? e + (e.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${t}` : e;\n  }\n  async _createTransport(e, t, n, o) {\n    let r = this._createConnectUrl(e, n.connectionToken);\n    if (this._isITransport(t)) {\n      this._logger.log(i.Debug, \"Connection was provided an instance of ITransport, using that directly.\"), this.transport = t, await this._startTransport(r, o), this.connectionId = n.connectionId;\n      return;\n    }\n    const c = [], a = n.availableTransports || [];\n    let l = n;\n    for (const u of a) {\n      const d = this._resolveTransportOrError(u, t, o, (l == null ? void 0 : l.useStatefulReconnect) === !0);\n      if (d instanceof Error)\n        c.push(`${u.transport} failed:`), c.push(d);\n      else if (this._isITransport(d)) {\n        if (this.transport = d, !l) {\n          try {\n            l = await this._getNegotiationResponse(e);\n          } catch (S) {\n            return Promise.reject(S);\n          }\n          r = this._createConnectUrl(e, l.connectionToken);\n        }\n        try {\n          await this._startTransport(r, o), this.connectionId = l.connectionId;\n          return;\n        } catch (S) {\n          if (this._logger.log(i.Error, `Failed to start the transport '${u.transport}': ${S}`), l = void 0, c.push(new Z(`${u.transport} failed: ${S}`, p[u.transport])), this._connectionState !== \"Connecting\") {\n            const H = \"Failed to select transport before stop() was called.\";\n            return this._logger.log(i.Debug, H), Promise.reject(new C(H));\n          }\n        }\n      }\n    }\n    return c.length > 0 ? Promise.reject(new ee(`Unable to connect to the server with any of the available transports. ${c.join(\" \")}`, c)) : Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\n  }\n  _constructTransport(e) {\n    switch (e) {\n      case p.WebSockets:\n        if (!this._options.WebSocket)\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        return new ke(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\n      case p.ServerSentEvents:\n        if (!this._options.EventSource)\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        return new ve(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\n      case p.LongPolling:\n        return new U(this._httpClient, this._logger, this._options);\n      default:\n        throw new Error(`Unknown transport: ${e}.`);\n    }\n  }\n  _startTransport(e, t) {\n    return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async (n) => {\n      let o = !1;\n      if (this.features.reconnect)\n        try {\n          this.features.disconnected(), await this.transport.connect(e, t), await this.features.resend();\n        } catch {\n          o = !0;\n        }\n      else {\n        this._stopConnection(n);\n        return;\n      }\n      o && this._stopConnection(n);\n    } : this.transport.onclose = (n) => this._stopConnection(n), this.transport.connect(e, t);\n  }\n  _resolveTransportOrError(e, t, n, o) {\n    const r = p[e.transport];\n    if (r == null)\n      return this._logger.log(i.Debug, `Skipping transport '${e.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`);\n    if (Ie(t, r))\n      if (e.transferFormats.map((a) => m[a]).indexOf(n) >= 0) {\n        if (r === p.WebSockets && !this._options.WebSocket || r === p.ServerSentEvents && !this._options.EventSource)\n          return this._logger.log(i.Debug, `Skipping transport '${p[r]}' because it is not supported in your environment.'`), new Q(`'${p[r]}' is not supported in your environment.`, r);\n        this._logger.log(i.Debug, `Selecting transport '${p[r]}'.`);\n        try {\n          return this.features.reconnect = r === p.WebSockets ? o : void 0, this._constructTransport(r);\n        } catch (a) {\n          return a;\n        }\n      } else\n        return this._logger.log(i.Debug, `Skipping transport '${p[r]}' because it does not support the requested transfer format '${m[n]}'.`), new Error(`'${p[r]}' does not support ${m[n]}.`);\n    else\n      return this._logger.log(i.Debug, `Skipping transport '${p[r]}' because it was disabled by the client.`), new Y(`'${p[r]}' is disabled by the client.`, r);\n  }\n  _isITransport(e) {\n    return e && typeof e == \"object\" && \"connect\" in e;\n  }\n  _stopConnection(e) {\n    if (this._logger.log(i.Debug, `HttpConnection.stopConnection(${e}) called while in state ${this._connectionState}.`), this.transport = void 0, e = this._stopError || e, this._stopError = void 0, this._connectionState === \"Disconnected\") {\n      this._logger.log(i.Debug, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is already in the disconnected state.`);\n      return;\n    }\n    if (this._connectionState === \"Connecting\")\n      throw this._logger.log(i.Warning, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${e}) was called while the connection is still in the connecting state.`);\n    if (this._connectionState === \"Disconnecting\" && this._stopPromiseResolver(), e ? this._logger.log(i.Error, `Connection disconnected with error '${e}'.`) : this._logger.log(i.Information, \"Connection disconnected.\"), this._sendQueue && (this._sendQueue.stop().catch((t) => {\n      this._logger.log(i.Error, `TransportSendQueue.stop() threw error '${t}'.`);\n    }), this._sendQueue = void 0), this.connectionId = void 0, this._connectionState = \"Disconnected\", this._connectionStarted) {\n      this._connectionStarted = !1;\n      try {\n        this.onclose && this.onclose(e);\n      } catch (t) {\n        this._logger.log(i.Error, `HttpConnection.onclose(${e}) threw error '${t}'.`);\n      }\n    }\n  }\n  _resolveUrl(e) {\n    if (e.lastIndexOf(\"https://\", 0) === 0 || e.lastIndexOf(\"http://\", 0) === 0)\n      return e;\n    if (!_.isBrowser)\n      throw new Error(`Cannot resolve '${e}'.`);\n    const t = window.document.createElement(\"a\");\n    return t.href = e, this._logger.log(i.Information, `Normalizing '${e}' to '${t.href}'.`), t.href;\n  }\n  _resolveNegotiateUrl(e) {\n    const t = new URL(e);\n    t.pathname.endsWith(\"/\") ? t.pathname += \"negotiate\" : t.pathname += \"/negotiate\";\n    const n = new URLSearchParams(t.searchParams);\n    return n.has(\"negotiateVersion\") || n.append(\"negotiateVersion\", this._negotiateVersion.toString()), n.has(\"useStatefulReconnect\") ? n.get(\"useStatefulReconnect\") === \"true\" && (this._options._useStatefulReconnect = !0) : this._options._useStatefulReconnect === !0 && n.append(\"useStatefulReconnect\", \"true\"), t.search = n.toString(), t.toString();\n  }\n}\nfunction Ie(s, e) {\n  return !s || (e & s) !== 0;\n}\nclass M {\n  constructor(e) {\n    this._transport = e, this._buffer = [], this._executing = !0, this._sendBufferedData = new P(), this._transportResult = new P(), this._sendLoopPromise = this._sendLoop();\n  }\n  send(e) {\n    return this._bufferData(e), this._transportResult || (this._transportResult = new P()), this._transportResult.promise;\n  }\n  stop() {\n    return this._executing = !1, this._sendBufferedData.resolve(), this._sendLoopPromise;\n  }\n  _bufferData(e) {\n    if (this._buffer.length && typeof this._buffer[0] != typeof e)\n      throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof e}`);\n    this._buffer.push(e), this._sendBufferedData.resolve();\n  }\n  async _sendLoop() {\n    for (; ; ) {\n      if (await this._sendBufferedData.promise, !this._executing) {\n        this._transportResult && this._transportResult.reject(\"Connection stopped.\");\n        break;\n      }\n      this._sendBufferedData = new P();\n      const e = this._transportResult;\n      this._transportResult = void 0;\n      const t = typeof this._buffer[0] == \"string\" ? this._buffer.join(\"\") : M._concatBuffers(this._buffer);\n      this._buffer.length = 0;\n      try {\n        await this._transport.send(t), e.resolve();\n      } catch (n) {\n        e.reject(n);\n      }\n    }\n  }\n  static _concatBuffers(e) {\n    const t = e.map((r) => r.byteLength).reduce((r, c) => r + c), n = new Uint8Array(t);\n    let o = 0;\n    for (const r of e)\n      n.set(new Uint8Array(r), o), o += r.byteLength;\n    return n.buffer;\n  }\n}\nclass P {\n  constructor() {\n    this.promise = new Promise((e, t) => [this._resolver, this._rejecter] = [e, t]);\n  }\n  resolve() {\n    this._resolver();\n  }\n  reject(e) {\n    this._rejecter(e);\n  }\n}\nconst Te = \"json\";\nclass Pe {\n  constructor() {\n    this.name = Te, this.version = 2, this.transferFormat = m.Text;\n  }\n  /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\n   *\n   * @param {string} input A string containing the serialized representation.\n   * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\n   */\n  parseMessages(e, t) {\n    if (typeof e != \"string\")\n      throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n    if (!e)\n      return [];\n    t === null && (t = I.instance);\n    const n = b.parse(e), o = [];\n    for (const r of n) {\n      const c = JSON.parse(r);\n      if (typeof c.type != \"number\")\n        throw new Error(\"Invalid payload.\");\n      switch (c.type) {\n        case h.Invocation:\n          this._isInvocationMessage(c);\n          break;\n        case h.StreamItem:\n          this._isStreamItemMessage(c);\n          break;\n        case h.Completion:\n          this._isCompletionMessage(c);\n          break;\n        case h.Ping:\n          break;\n        case h.Close:\n          break;\n        case h.Ack:\n          this._isAckMessage(c);\n          break;\n        case h.Sequence:\n          this._isSequenceMessage(c);\n          break;\n        default:\n          t.log(i.Information, \"Unknown message type '\" + c.type + \"' ignored.\");\n          continue;\n      }\n      o.push(c);\n    }\n    return o;\n  }\n  /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\n   *\n   * @param {HubMessage} message The message to write.\n   * @returns {string} A string containing the serialized representation of the message.\n   */\n  writeMessage(e) {\n    return b.write(JSON.stringify(e));\n  }\n  _isInvocationMessage(e) {\n    this._assertNotEmptyString(e.target, \"Invalid payload for Invocation message.\"), e.invocationId !== void 0 && this._assertNotEmptyString(e.invocationId, \"Invalid payload for Invocation message.\");\n  }\n  _isStreamItemMessage(e) {\n    if (this._assertNotEmptyString(e.invocationId, \"Invalid payload for StreamItem message.\"), e.item === void 0)\n      throw new Error(\"Invalid payload for StreamItem message.\");\n  }\n  _isCompletionMessage(e) {\n    if (e.result && e.error)\n      throw new Error(\"Invalid payload for Completion message.\");\n    !e.result && e.error && this._assertNotEmptyString(e.error, \"Invalid payload for Completion message.\"), this._assertNotEmptyString(e.invocationId, \"Invalid payload for Completion message.\");\n  }\n  _isAckMessage(e) {\n    if (typeof e.sequenceId != \"number\")\n      throw new Error(\"Invalid SequenceId for Ack message.\");\n  }\n  _isSequenceMessage(e) {\n    if (typeof e.sequenceId != \"number\")\n      throw new Error(\"Invalid SequenceId for Sequence message.\");\n  }\n  _assertNotEmptyString(e, t) {\n    if (typeof e != \"string\" || e === \"\")\n      throw new Error(t);\n  }\n}\nconst Re = {\n  trace: i.Trace,\n  debug: i.Debug,\n  info: i.Information,\n  information: i.Information,\n  warn: i.Warning,\n  warning: i.Warning,\n  error: i.Error,\n  critical: i.Critical,\n  none: i.None\n};\nfunction De(s) {\n  const e = Re[s.toLowerCase()];\n  if (typeof e < \"u\")\n    return e;\n  throw new Error(`Unknown log level: ${s}`);\n}\nclass $e {\n  configureLogging(e) {\n    if (f.isRequired(e, \"logging\"), xe(e))\n      this.logger = e;\n    else if (typeof e == \"string\") {\n      const t = De(e);\n      this.logger = new R(t);\n    } else\n      this.logger = new R(e);\n    return this;\n  }\n  withUrl(e, t) {\n    return f.isRequired(e, \"url\"), f.isNotEmpty(e, \"url\"), this.url = e, typeof t == \"object\" ? this.httpConnectionOptions = { ...this.httpConnectionOptions, ...t } : this.httpConnectionOptions = {\n      ...this.httpConnectionOptions,\n      transport: t\n    }, this;\n  }\n  /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\n   *\n   * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\n   */\n  withHubProtocol(e) {\n    return f.isRequired(e, \"protocol\"), this.protocol = e, this;\n  }\n  withAutomaticReconnect(e) {\n    if (this.reconnectPolicy)\n      throw new Error(\"A reconnectPolicy has already been set.\");\n    return e ? Array.isArray(e) ? this.reconnectPolicy = new L(e) : this.reconnectPolicy = e : this.reconnectPolicy = new L(), this;\n  }\n  /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\n   *\n   * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\n   */\n  withServerTimeout(e) {\n    return f.isRequired(e, \"milliseconds\"), this._serverTimeoutInMilliseconds = e, this;\n  }\n  /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\n   *\n   * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\n   */\n  withKeepAliveInterval(e) {\n    return f.isRequired(e, \"milliseconds\"), this._keepAliveIntervalInMilliseconds = e, this;\n  }\n  /** Enables and configures options for the Stateful Reconnect feature.\n   *\n   * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\n   */\n  withStatefulReconnect(e) {\n    return this.httpConnectionOptions === void 0 && (this.httpConnectionOptions = {}), this.httpConnectionOptions._useStatefulReconnect = !0, this._statefulReconnectBufferSize = e == null ? void 0 : e.bufferSize, this;\n  }\n  /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\n   *\n   * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\n   */\n  build() {\n    const e = this.httpConnectionOptions || {};\n    if (e.logger === void 0 && (e.logger = this.logger), !this.url)\n      throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\n    const t = new Ee(this.url, e);\n    return A.create(t, this.logger || I.instance, this.protocol || new Pe(), this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize);\n  }\n}\nfunction xe(s) {\n  return s.log !== void 0;\n}\nclass Ae {\n  constructor(e, t, n) {\n    w(this, \"hubConnection\");\n    w(this, \"interval\", null);\n    w(this, \"onConnectedCallbacks\", []);\n    w(this, \"onDisconnectedCallbacks\", []);\n    w(this, \"callbacks\", {\n      GameStatusUpdate: {},\n      Pong: {},\n      SelectAnswer: {},\n      MiniGameNotification: {}\n    });\n    w(this, \"addOnConnectedCallback\", (e) => {\n      this.onConnectedCallbacks.push(e);\n    });\n    w(this, \"addOnDisconnectedCallback\", (e) => {\n      this.onDisconnectedCallbacks.push(e);\n    });\n    w(this, \"removeOnConnectedCallback\", (e) => {\n      this.onConnectedCallbacks = this.onConnectedCallbacks.filter(\n        (t) => t !== e\n      );\n    });\n    w(this, \"removeOnDisconnectedCallback\", (e) => {\n      this.onDisconnectedCallbacks = this.onDisconnectedCallbacks.filter(\n        (t) => t !== e\n      );\n    });\n    w(this, \"onSync\", (e, t, n) => {\n      this.callbacks[e][n] = t, this.reloadSync(e);\n    });\n    w(this, \"offSync\", (e, t) => {\n      t && delete this.callbacks[e][t], this.reloadSync(e);\n    });\n    w(this, \"reloadSync\", (e) => {\n      var n, o;\n      const t = Object.entries(this.callbacks[e]);\n      (n = this.hubConnection) == null || n.off(e), (o = this.hubConnection) == null || o.on(e, (r) => {\n        t.forEach(([, c]) => c(r));\n      });\n    });\n    w(this, \"sendSync\", async (e, t) => {\n      var n, o;\n      t != null ? await ((n = this.hubConnection) == null ? void 0 : n.invoke(e, t)) : await ((o = this.hubConnection) == null ? void 0 : o.invoke(e));\n    });\n    w(this, \"_reconnectInterval\", () => {\n      this.interval = setTimeout(async () => {\n        var e;\n        ((e = this.hubConnection) == null ? void 0 : e.state) === g.Disconnected && await this._connect();\n      }, 1e3);\n    });\n    this.wsUrl = e, t && this.onConnectedCallbacks.push(t), n && this.onDisconnectedCallbacks.push(n), this.hubConnection = new $e().withUrl(this.wsUrl).withKeepAliveInterval(12e4).build();\n  }\n  async _connect() {\n    var e, t;\n    try {\n      (e = this.hubConnection) == null || e.onclose(() => {\n        this.onDisconnectedCallbacks.forEach((n) => n());\n      }), await ((t = this.hubConnection) == null ? void 0 : t.start()), this.onConnectedCallbacks.forEach((n) => n());\n    } catch (n) {\n      console.error(\"Error while starting connection: \", n), this.onDisconnectedCallbacks.forEach((o) => o());\n    }\n  }\n  async init() {\n    var e;\n    if (this.isConnected()) {\n      console.warn(\n        `LocalSyncService is already connected to ${(e = this.hubConnection) == null ? void 0 : e.baseUrl}`\n      );\n      return;\n    }\n    this.removeOnDisconnectedCallback(this._reconnectInterval), this.addOnDisconnectedCallback(this._reconnectInterval), await this._connect();\n  }\n  isConnected() {\n    var e;\n    return ((e = this.hubConnection) == null ? void 0 : e.state) === g.Connected;\n  }\n  async dispose() {\n    if (this.interval && (clearInterval(this.interval), this.interval = null), this.hubConnection)\n      try {\n        await this.hubConnection.stop();\n      } catch (e) {\n        console.error(\"Error while stopping connection: \", e);\n      }\n  }\n}\nconst Oe = ({\n  children: s,\n  wsUrl: e\n}) => {\n  const [t, n] = G(!1), o = J(\n    new Ae(\n      e,\n      () => {\n        n(!0), console.log(\"Connected to LocalSyncService\");\n      },\n      () => {\n        n(!1), console.log(\"Disconnected from LocalSyncService\");\n      }\n    )\n  );\n  return K(() => {\n    const r = o.current;\n    return r.init(), () => {\n      r.dispose();\n    };\n  }, [o]), /* @__PURE__ */ z(\n    X.Provider,\n    {\n      value: {\n        addOnConnect: o.current.addOnConnectedCallback,\n        addOnDisconnect: o.current.addOnDisconnectedCallback,\n        removeOnConnect: o.current.removeOnConnectedCallback,\n        removeOnDisconnect: o.current.removeOnDisconnectedCallback,\n        connected: t,\n        offSync: o.current.offSync,\n        onSync: o.current.onSync,\n        sendSync: o.current.sendSync\n      },\n      children: s\n    }\n  );\n};\nexport {\n  V as GameStatus,\n  Le as GameStatusNames,\n  Oe as LocalSyncServiceProvider\n};\n//# sourceMappingURL=main.js.map\n","export const cleanupSlash = (path: string) => path.replace(/\\/{2,}/g, \"/\");\n","import { useLocalSyncConsumer } from \"@/hooks\";\nimport { SyncReceiveDefinitionNames } from \"@/services/types\";\nimport { cleanupSlash } from \"@/utility\";\nimport { Route, Routes, useLocation, useNavigate } from \"react-router\";\n\ninterface Props<TMessage> {\n  basePath?: string;\n  identifier: string;\n  routes: Record<string, JSX.Element>;\n  queueName: SyncReceiveDefinitionNames;\n  createNavigationPath: (message: TMessage) => string;\n}\n\nconst GenericNavigator = <TMessage,>({\n  queueName,\n  basePath,\n  identifier: key,\n  createNavigationPath,\n  routes,\n}: Props<TMessage>) => {\n  const navigate = useNavigate();\n  const { pathname } = useLocation();\n  const pathSection = cleanupSlash(`/${basePath ?? \"\"}/`);\n  const locationBasePath = pathname.includes(pathSection)\n    ? pathname.split(pathSection)[0] + pathSection\n    : pathname;\n\n  useLocalSyncConsumer(queueName, key, (message) => {\n    navigate(\n      cleanupSlash(\n        `${locationBasePath}${createNavigationPath(message as TMessage)}`,\n      ),\n    );\n  });\n\n  return (\n    <Routes>\n      {Object.entries(routes).map(([path, element]) => (\n        <Route key={path} path={path} element={element as JSX.Element} />\n      ))}\n    </Routes>\n  );\n};\n\nexport default GenericNavigator;\n","import { GameStatus } from \"quiz-common-ui\";\nimport { useCallback, useMemo } from \"react\";\nimport { Route, Routes } from \"react-router\";\nimport GenericNavigator from \"./GenericNavigator\";\nimport { SyncReceiveData } from \"@/services/types\";\nimport { cleanupSlash } from \"@/utility\";\n\ntype Props = {\n  basePath: string;\n  pages: {\n    [GameStatus.GameCreated]: JSX.Element;\n    [GameStatus.GameJoined]: JSX.Element;\n    [GameStatus.GameStarting]: JSX.Element;\n    [GameStatus.RulesExplaining]: JSX.Element;\n    [GameStatus.MiniGameStarting]: JSX.Element;\n    [GameStatus.MiniGameStarted]: JSX.Element;\n    [GameStatus.MiniGameEnding]: JSX.Element;\n    [GameStatus.GameEnding]: JSX.Element;\n  };\n};\n\nconst GameNavigator = ({ pages, basePath }: Props) => {\n  const createNavigationPath = useCallback(\n    (message: SyncReceiveData[\"GameStatusUpdate\"]) => {\n      switch (message?.status) {\n        case GameStatus.GameCreated:\n          return `${message.gameId}/created/`;\n        case GameStatus.GameJoined:\n          return `${message.gameId}/joined/`;\n        case GameStatus.GameStarting:\n          return `${message.gameId}/starting/`;\n        case GameStatus.RulesExplaining:\n          return `${message.gameId}/rules/`;\n        case GameStatus.MiniGameStarting:\n          return `${message.gameId}/minigame/`;\n        case GameStatus.MiniGameStarted:\n          return `${message.gameId}/minigame_play/`;\n        case GameStatus.MiniGameEnding:\n          return `${message.gameId}/minigame_finish/`;\n        case GameStatus.GameEnding:\n          return `${message.gameId}/end/`;\n        default:\n          return \"\";\n      }\n    },\n    [],\n  );\n  const routes = useMemo<Record<string, JSX.Element>>(\n    () => ({\n      \":gameId/created/*\": pages[GameStatus.GameCreated],\n      \":gameId/join/*\": pages[GameStatus.GameJoined],\n      \":gameId/starting/*\": pages[GameStatus.GameStarting],\n      \":gameId/rules/*\": pages[GameStatus.RulesExplaining],\n      \":gameId/minigame/*\": pages[GameStatus.MiniGameStarting],\n      \":gameId/minigame_play/*\": pages[GameStatus.MiniGameStarted],\n      \":gameId/minigame_finish/*\": pages[GameStatus.MiniGameEnding],\n      \":gameId/end/*\": pages[GameStatus.GameEnding],\n    }),\n    [pages],\n  );\n\n  return (\n    <Routes>\n      <Route\n        path=\"game/*\"\n        element={\n          <GenericNavigator<SyncReceiveData[\"GameStatusUpdate\"]>\n            basePath={cleanupSlash(basePath + \"/game\")}\n            identifier={\"GameNavigator\"}\n            routes={routes}\n            queueName={\"GameStatusUpdate\"}\n            createNavigationPath={createNavigationPath}\n          />\n        }\n      />\n    </Routes>\n  );\n};\n\nexport default GameNavigator;\n"],"names":["getRandomBorderPosition","squareSize","position","randomValue","flySquare","square","startPosition","endPosition","duration","startTime","animate","time","elapsed","progress","FlyingSquare","count","squareRefs","useRef","useEffect","jsx","_","index","el","styles","FlyingSquare$1","memo","Latency","latency","setLatency","useState","timestamp","connected","sendSync","useLocalSyncService","interval","useLocalSyncConsumer","useCallback","newLatency","hasOwn","classNames","classes","arg","appendClass","parseValue","key","value","newClass","module","Tile","text","blue","selected","success","failure","onClick","Timer","startSeconds","onTimeUp","timeLeft","setTimeLeft","percentage","setPercentage","prevTime","timeElapsed","getProgressColor","jsxs","o","V","s","i","h","g","p","m","cleanupSlash","path","GenericNavigator","queueName","basePath","createNavigationPath","routes","navigate","useNavigate","pathname","useLocation","pathSection","locationBasePath","message","Routes","element","Route","GameNavigator","pages","GameStatus","useMemo"],"mappings":"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","x_google_ignoreList":[3]}